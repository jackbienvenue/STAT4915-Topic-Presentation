---
title: Animated Weather Mapping for ECMWF
author: Jack Bienvenue
date: 8 Februrary 2025
---

In this file, we will experiment with creating dynamic/ animated weather maps for the state of Connecticut using weather data we retrieved and cleaned from the European Center for Medium-Range Weather Forecasting.

Let's begin by checking our grid cells and ensuring that they are loaded in properly:
``` {python}
#| echo: false

import pandas as pd
import geopandas as gpd
import folium
import os
import plotly.express as px
from shapely.geometry import Point

# File paths
shapefile_path = "../data/grid_cell_shapefile/grid_cells.shp"
csv_path = '../data/csv_for_input_into_viz.csv'

# Load grid cells shapefile
gdf_grid_cells = gpd.read_file(shapefile_path).to_crs("EPSG:26986")

# Load the CSV with weather data
gdf_all_weather = pd.read_csv(csv_path)

# Convert CSV to GeoDataFrame using latitude and longitude
geometry = [Point(lon, lat) for lon, lat in zip(gdf_all_weather['longitude'], gdf_all_weather['latitude'])]
gdf_all_weather = gpd.GeoDataFrame(gdf_all_weather, geometry=geometry, crs="EPSG:26986")


# Perform a spatial join with grid cells (to merge weather data with grid cells)
gdf_joined = gpd.sjoin(gdf_all_weather, gdf_grid_cells, how="left", predicate="within")

# Ensure 'time' is a datetime object, coercing errors
gdf_joined['time'] = pd.to_datetime(gdf_joined['time'], errors='coerce')

# Drop rows where 'time' could not be converted
gdf_joined = gdf_joined.dropna(subset=['time'])

# Extract just the date part (without hours, minutes, seconds)
gdf_joined['time'] = gdf_joined['time'].dt.date

# Now, we can proceed with filtering based on the year and specific date range
gdf_filtered = gdf_joined[gdf_joined['time'].apply(lambda x: 2020 <= x.year <= 2023)]
gdf_filtered = gdf_filtered[(gdf_filtered['time'] >= pd.to_datetime('2022-01-01').date()) & 
                             (gdf_filtered['time'] <= pd.to_datetime('2022-01-14').date())]

print(gdf_joined.head())

# Create a map centered around the data points
def create_map(gdf, start_lat, start_lon, zoom_start=6):
    # Create a folium map centered at an initial latitude and longitude
    folium_map = folium.Map(location=[start_lat, start_lon], zoom_start=zoom_start)
    
    # Add markers for each weather data point in the GeoDataFrame
    for _, row in gdf.iterrows():
        folium.Marker(
            location=[row['latitude'], row['longitude']],
            popup=f"Date: {row['time']}\nTemperature: {row['t2m']}",  # Replace with relevant column name
        ).add_to(folium_map)
    
    return folium_map

# Set initial map location to the center of your area of interest
start_lat, start_lon = gdf_filtered['latitude'].mean(), gdf_filtered['longitude'].mean()

# Create the map
weather_map = create_map(gdf_filtered, start_lat, start_lon)
weather_map.save('weather_map.html')

# Convert 'time' to a string format directly (without using .dt accessor)
gdf_filtered['time'] = gdf_filtered['time'].apply(lambda x: str(x))

# Now proceed with the animation part
geojson_data = gdf_filtered.to_json()

fig = px.choropleth(
    gdf_filtered,
    geojson=geojson_data,
    locations=gdf_filtered.index,
    color="t2m",
    hover_name="FID",
    #animation_frame="time",
    color_continuous_scale="Viridis",
    title="Grid of Polygons with Time Slider"
)

fig.update_geos(fitbounds="locations")
fig.write_html('./weather_animation.html')
print("Animation saved to ./weather_animation.html")

```

```{python}
import folium
from folium.plugins import TimeSliderChoropleth
import pandas as pd
import geopandas as gpd

# Example: Assume gdf_filtered is already created
# Convert the filtered GeoDataFrame to GeoJSON format
geojson_data = gdf_filtered.to_json()

# Create a styledict for time slider choropleth
# For simplicity, we're using a color scale based on 't2m' (temperature) for each time period
styledict = {
    str(date): {
        'color': f'#{int((temp + 50) * 255 / 100):02x}{int((temp + 50) * 255 / 100):02x}00'
    }
    for date, temp in zip(gdf_filtered['time'].unique(), gdf_filtered['t2m'])
}

# Calculate the center for the map (average latitude and longitude)
latitude = gdf_filtered['latitude'].mean()
longitude = gdf_filtered['longitude'].mean()

# Create the map
folium_map = folium.Map(location=[latitude, longitude], zoom_start=6)

# Create the time slider choropleth and add it to the map
TimeSliderChoropleth(geojson_data, styledict=styledict).add_to(folium_map)

# Display the map
folium_map

```