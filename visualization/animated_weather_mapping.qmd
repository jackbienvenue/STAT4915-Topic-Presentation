---
title: Animated Weather Mapping for ECMWF
author: Jack Bienvenue
date: 8 Februrary 2025
---

In this file, we will experiment with creating dynamic/ animated weather maps for the state of Connecticut using weather data we retrieved and cleaned from the European Center for Medium-Range Weather Forecasting.

Let's begin by checking our grid cells and ensuring that they are loaded in properly:
``` {python}
#| echo: false
#| eval: true

# Package Import:

import pandas as pd
import geopandas as gpd
import matplotlib.pyplot as plt
import os
from shapely.geometry import Point
import plotly.express as px
import folium # Printing maps for debugging stages
from folium import GeoJson

# Data Connection:

    # Shapefile import:

shapefile_path = "../data/grid_cell_shapefile/grid_cells.shp"
gdf_grid_cells = gpd.read_file(shapefile_path)
gdf_grid_cells = gdf_grid_cells.to_crs("EPSG:26986")

    # Dataframe with weather data folder import:

csv_folder_path = '../data/individual_csvs_daily'
# Load grid cells shapefile once, outside the loop
shapefile_path = "../data/grid_cell_shapefile/grid_cells.shp"
gdf_grid_cells = gpd.read_file(shapefile_path)
gdf_grid_cells = gdf_grid_cells.to_crs("EPSG:26986")

weather_data_gdfs = []


##### DEBUGGING CHECK - GRID CELL MAP:

m = folium.Map(location=[41.6032, -73.0877], zoom_start=8)
# Convert the grid cell GeoDataFrame to GeoJSON format
geojson_data = gdf_grid_cells.to_json()
# Add the GeoJSON data (grid cells) to the Folium map
GeoJson(geojson_data, name="Grid Cells").add_to(m)
# Optional: Add a layer control for toggling between different map layers
folium.LayerControl().add_to(m)
# Save the map to an HTML file
m.save('grid_cells_CT_map.html')
# To display the map in a Jupyter notebook (if running in one):
m
```

# Iterate through the CSV files and load weather data
for csv_file in os.listdir(csv_folder_path):
    if csv_file.endswith('.csv'):
        # Load the CSV
        df = pd.read_csv(os.path.join(csv_folder_path, csv_file))
        
        # Create geometry (Point from lat/lon)
        geometry = [Point(lon, lat) for lon, lat in zip(df['longitude'], df['latitude'])]
        
        # Convert to GeoDataFrame
        gdf_weather = gpd.GeoDataFrame(df, geometry=geometry, crs="EPSG:26986")
        
        # Perform the spatial join only once
        gdf_joined = gpd.sjoin(gdf_weather, gdf_grid_cells, how="left", predicate="within")
        
        # Add the joined GeoDataFrame to the list
        weather_data_gdfs.append(gdf_joined)

# Concatenate all the joined dataframes into one
gdf_all_weather = pd.concat(weather_data_gdfs, ignore_index=True)

# Ensure 'time' column is in datetime format
gdf_all_weather['time'] = pd.to_datetime(gdf_all_weather['time'], errors='coerce')

# Now you can apply the .dt accessor
gdf = gdf_all_weather[(gdf_all_weather['time'].dt.year >= 2020) & (gdf_all_weather['time'].dt.year <= 2023)]

start_date = '2022-01-01'
end_date = '2022-01-14'

gdf = gdf[(gdf_all_weather['time'] >= start_date) & (gdf_all_weather['time'] <= end_date)]

```

Before we begin mapping, we have to perform a spatial join to unify the data we have about the weather trends with the shapefiles we have created for the grid cells which cover the state of Connecticut. 

Now, we can move onto mapping and building our animation!

``` {python}
#| echo: false
#| eval: false

# Convert the 'time' column to string to make it JSON serializable
gdf['time'] = gdf['time'].dt.strftime('%Y-%m-%d')  # Convert to string format

# Convert the GeoDataFrame to GeoJSON format
geojson_data = gdf.to_json()

fig = px.choropleth(
    gdf,
    geojson=geojson_data,
    locations=gdf.index,
    color="t2m",
    hover_name="FID",
    animation_frame="time",  # Time-based animation
    color_continuous_scale="Viridis",
    title="Grid of Polygons with Time Slider"
)

fig.update_geos(fitbounds="locations")  # Optional: to make sure the map fits to the data bounds

# Save the figure as an HTML file
output_path = "./weather_animation.html"
fig.write_html(output_path)

# Optional: print path to file
print(f"Animation saved to {output_path}")

```